# CS 탐구생활 2주차

팀원: 이노규, 최선우, 이태헌, 안주현

## 주제

- [운영체제](https://thecrashcourse.com/courses/operating-systems-crash-course-computer-science-18/)

## 운영체제

- 컴퓨터가 스스로 동작할 수 있도록 만들어진 프로그램이다.

- 하드웨어에 특별한 권한으로 다른 프로그램을 실행하고 관리할 수 있다.

- 컴퓨터를 켰을 때 가장 먼저 시작하는 프로그램이다.

## 최초의 OS

- **일괄처리**가 구현되어 수작업으로 프로그램을 로드하는 수동 작업을 보강했다.

- 컴퓨터가 입력받은 프로그램을 순서대로 실행하고, 실행이 끝나면 다음 프로그램을 실행하는 방식이다. 

- 과거 컴퓨터는 하드웨어와의 연결성이 안좋았기 때문에 하드웨어마다 프로그램을 따로 만들어야 했다.

- 운영체제는 API를 통해 하드웨어를 추상화하여 표준화된 입출력을 제공하였고 이를 통해 하드웨어의 종류에 상관없이 프로그램을 만들 수 있게 되었다.

## blocking

컴퓨터 성능이 발전함에 따라 IO에 걸리는 시간동안 CPU가 노는 현상이 발생하였다.

### 아틀라스

- 최초의 슈퍼컴퓨터이다.

- 단일 CPU에서 여러 프로그램을 실행할 수 있었다.

수천 cycle이 걸리는 IO 작업이 있다면 해당 프로그램을 멈추고 다른 프로그램을 실행하다 io가 끝나 프로그램이 준비되면 다시 시작하도록 구현되었다.

덕분에 멀티테스킹이 가능하였다.

![process-state](https://img1.daumcdn.net/thumb/R1280x0/?scode=mtistory2&fname=https%3A%2F%2Ft1.daumcdn.net%2Fcfile%2Ftistory%2F99E85E3A5C460F1906)

### 메모리 문제

프로그램이 실행되면 메모리가 필요하게 되는데 메모리를 할당하는 과정에서 문제가 발생한다.

| 메모리 위치 | 프로그램 |
| :---------: | :------: |
|    0~999    |    A     |
|  1000-1999  |    B     |
|  2000-2999  |   None   |

위와 같은 상황에서 A에게 새로운 메모리를 할당하면

| 메모리 위치 | 프로그램 |
| :---------: | :------: |
|    0~999    |    A     |
|  1000-1999  |    B     |
|  2000-2999  |    A     |

다음과 같아지는데 A의 메모리 위치가 달라져 프로그래머가 메모리를 추적하기 메우 어려워 진다.

게다가 실제로는 메모리 전체에 수십 블록이 위와 같이 떨어져 있을 수 있다.

### 메모리 가상화

그래서 운영체제가 메모리 주소를 가상화 하였다.

실제 물리적 메모리 위치는 떨어져 있지만 운영체제에 의해 추상화 되고 숨겨져 프로그램은 0에서 부터 시작하는 연속된 메모리 공간이라고 인식하게 된다.

| 실제 메모리 위치 | 가상 메모리 위치 | 프로그램 |
| :--------------: | :--------------: | :------: |
|      0~999       |      0~999       |    A     |
|    1000-1999     |      0~999       |    B     |
|    2000-2999     |    1000~1999     |    A     |

실제론 다른 위치에 있지만 프로그램이 가상 메모리 위치를 호출하면 운영체제가 실제 메로리 주소로 변환하여 데이터를 참조한다.

그렇기에 프로그램은 실제 메로리 주소를 볼 수 없어 메모리가 보호된다.

즉 프로그램에 버그가 생기면 해당 프로그램의 메모리 블록만 제거하여 시스템을 보호한다.

위와 같은 방법으로 운영체제는 프로그램에 메모리를 유연하게 할당할 수 있는데 **동적 메모리 할당**이라고 한다.

![memory](https://velog.velcdn.com/images/chaemin/post/6ddbb077-e2bd-4d29-b3e1-f133ad5ea5e8/image.PNG)

### 메모리 보호

여러 사용자가 컴퓨터를 사용할 수 있게 되면서  
특정 유저가 자원을 모두 쓸 수 없도록 운영체제는 **time sharing** 기능을 제공하도록 개발되었다.  
개별 사용자는 **time sharing**으로 컴퓨터 자원의 일부분만 사용할 수 있다.  
컴퓨터가 발전해 전체 리소스의 1/50 으로도 작업하기엔 충분했기에 가능하였다.

## mutics

- 처음부터 안전하도록 설계된 최초의 운영체제이다.

- 여러 기능을 제공했고 덕분에 당시로선 많은 1메가의 메모리를 사용하였다.

- 너무 무거웠기 때문에 꾸준히 발전할 수 없었고 개발자가 Unix를 만들었다.

## Unix

mutics에서 교훈을 얻어 운영체제를 두 부분으로 나누었다.

- 커널: 하드웨어와 상호작용하는 부분
- 도구: 프로그램과 라이브러리

커널은 의도적으로 일부의 기능만 남겨두어 운영체제를 가볍게 만들었다.

유닉스에서 오류가 발생하면 패닉이라는 루틴을 갖고 기계가 충돌한다.

즉 커널이 죽고 재부팅된다.

## ms-dos

초기 가정용 컴퓨터로 멀티테스킹과 메모리 보호는 부족하였다.

## 윈도우 초기 버전

메모리 보호 기능이 없어 프로그램이 잘못 충돌하면 블루스크린이 뜨기 일쑤였다.

최근 컴퓨터는 혼자 사용하는 경우가 많지만 모두 멀티테스킹과 메모리 보호를 갖고 있다.