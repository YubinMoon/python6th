# CS 탐구생활 3주차

팀원: 전예진, 이근한, 최선우, 김민혁

## 주제

- [파일시스템](https://thecrashcourse.com/courses/files-file-systems-crash-course-computer-science-20/)

## 파일 포멧

컴퓨터가 데이터를 저장하는 방식은 결국엔 0과 1 이진수 이기에 이진수를 어떤 순서로 저장하든지 전혀 상관이 없다.

대신 파일 내부의 이진수가 어떻게 조직되어 있는지 정한 규칙이 파일 포멧이다.

가장 쉬운 예로 jpeg나 mp3같은 표준 파일 포멧이 있다.

### txt

가장 간단한 텍스트 파일 형식이다.

파일 내부는 2진수로 되어 있지만 보통 ascii나 utf-8로 인코딩된 수가 연속으로 나열되어 있다.

파일의 시작 부분부터 텍스트가 시작되어 따로 인코딩 정보가 없어 인코딩은 파일을 여는 프로그램이 판단하게 된다.

주로 utf-8을 사용한다.

### wav

오디오 저장 방식이다.

데이터에 관한 데이터를 메타 데이터라고 한다.

파일에서 실제 데이터보다 먼저 나와 파일을 설명하는 데이터를 헤더라고 메타 데이터는 헤더에 들어있다.

wav 파일의 헤더 부분에는 오디오 데이터를 읽을 수 있도록 bit rate, mono or stereo, 같은 메타데이터가 들어있다.

### BMPs

비트맵 사진 저장 방식이다.

비트맵은 헤더에는 이미지의 크기와 색 깊이 같은 메타 데이터가 들어있다.

이 데이터를 통해 이후에 오는 데이터를 통해 어떻게 이미지를 그릴지 알 수 있다.

## 저장 장치

여러 파일 형식이 있지만 모든 파일의 공통점은 모두 2진수로 저장된 긴 숫자 목록이라는 점이다.

여러 방식의 저장 장치가 있지만 결국 값을 저장하는 긴 줄로 추상화 할 수 있다.

### 저장

예전에는 전체 저장 장치가 하나의 큰 파일처럼 동작하여 데이터는 저장 장치의 처음부터 시작해 출력이 생긴 순서대로 저장 장치를 채웠다.

저장 용량이 향상되어 한번에 둘 이상의 파일을 저장할 수 있게 되었고 데이터를 저장하는 방법이 필요했다.

가장 간단한 방법은 파일을 연속으로 저장하는 것이다.

파일을 연속으로 저장하면 컴퓨터가 파일의 시작과 끝을 알 방법이 필요했는데 저장 장치는 파일 개념이 없기 때문에 다른 파일이 있는 위치를 기록하는 특수 파일을 만들었다.

대부분 저장 공간의 앞쪽에 보관되어 엑세스 할 위치를 항상 알 수 있는 이 파일은 보통 DIRECTORY FILE이라고 한다.

### DIRECTORY FILE

디렉토리 파일에는 저장곤간의 다른 모든 파일의 이름과 함께 저장소에서 파일이 시작되는 위치와 길이가 들어 있다.

또 디렉토리 파일은 생성되거나 수정된 날짜, 주인, 읽기/쓰기 권한 같은 추가적인 데이터도 저장한다.

**DIRECTORY FILE**

|   NAME   |  CREATED   | LAST MODIFIED | OWNER | READ/WRITE | BEGIN | LENGTH |
| :------: | :--------: | :-----------: | :---: | :--------: | :---: | :----: |
| todo.txt | 2023/05/13 |  2023/06/05   | user1 |    r/w     |  10   |   13   |
| abc.wav  | 2023/02/12 |  2023/04/12   | user2 |     r      |  23   |   31   |
| test.py  | 2023/06/05 |  2023/06/14   | user1 |    r/w     |  54   |   70   |
|  a.out   | 2023/06/14 |  2023/06/14   | user2 |    r/w     |  124  |   25   |

파일을 업데이트 하면 디렉토리 파일도 업데이트 해야 한다.

디렉토리 파일의 유지는 파일을 관리하고 파악하는 운영 체제의 매우 기본적인 파일 시스템의 예시다.

위의 예시에선 모두 하나의 레벨에 저장되기 대문에 Flat File System이라고 한다.
 

파일들을 서로 맞닿게 묶어서 저장하는 것은 데이터를 추가할 때 뒤쪽 파일의 영역이 필요하게 되는 문제가 있다.

위 문제를 해결하기 위해 현대 파일 시스템은 두 가지를 한다.

- 파일을 블록 단위로 저장  

  파일을 저장할 때 약간의 여유 공간이 남게 되는데 SLACK SPACE라고 한다.  
  또 모든 파일 데이터가 공통 크기로 정렬되어 관리가 간단해진다.  
  그래서 디렉토리 파일의 시작과 길이 대신 파일이 저장된 블록을 파악해야 한다.

  **DIRECTORY FILE**

  |   NAME   |  CREATED   | LAST MODIFIED | OWNER | READ/WRITE | BLOCKS |
  | :------: | :--------: | :-----------: | :---: | :--------: | :----: |
  | todo.txt | 2023/05/13 |  2023/06/05   | user1 |    r/w     |   1    |
  | abc.wav  | 2023/02/12 |  2023/04/12   | user2 |     r      |   2    |
  | test.py  | 2023/06/05 |  2023/06/14   | user1 |    r/w     |   3    |
  |  a.out   | 2023/06/14 |  2023/06/14   | user2 |    r/w     |   4    |

- 파일이 덩어리로 분해되어 여러 블록에 저장

  예를 들어 todo.txt의 파일이 너무 커져 1번 블록에 저장할 수 없게 되면 비어있는 새 블록에 이어서 저장할 수 있다.  
  이를 위해 디렉토리 파일에는 파일이 저장된 블록이 순서대로 들어있다.

  **DIRECTORY FILE**

  |   NAME   |  CREATED   | LAST MODIFIED | OWNER | READ/WRITE | BLOCKS  |
  | :------: | :--------: | :-----------: | :---: | :--------: | :-----: |
  | todo.txt | 2023/05/13 |  2023/06/05   | user1 |    r/w     | 1, 6, 7 |
  | abc.wav  | 2023/02/12 |  2023/04/12   | user2 |     r      |    2    |
  | test.py  | 2023/06/05 |  2023/06/14   | user1 |    r/w     |  3, 5   |
  |  a.out   | 2023/06/14 |  2023/06/14   | user2 |    r/w     |    4    |

  파일이 지워질 때도 디렉토리 파일에서만 파일을 지우면 되므로 실제 브록에 있는 데이터는 남겨 두었다. 나중에 덮어 쓰면 된다.

  이 덕분에 지운지 얼마 되지 않은 파일은 복구가 가능하다.

디렉토리를 생성, 삭제, 수정 하다 보면 파일이 여러 분리된 블럭에 나뉘어 저장되게 된다.

이는 저장 공간에서 여러 부분을 옮겨 다니며 데이터를 읽고 써야 하기 때문에 성능이 떨어진다.

그래서 DEFRAGMENTATION라는 기술을 활용한다.

### DEFRAGMENTATION

컴퓨터가 데이터를 복사하여 저장소에 있는 파일 블록들을 올바른 순서로 다시 배치한다.

그러면 이제 여러 블록에 있는 파일도 블록이 순서대로 정렬되어 파일을 순서대로 읽을 수 있게 된다.

## Hierarchical File System

모든 파일을 하나의 디렉토리에서 관리하는 건 효율적이지 못하다.

관련된 파일을 폴더로 묶고 그 폴더를 폴더에 넣는 방식이 좋다.

이것이 Hierarchical File System(계층적 파일 시스템)이다.

이는 디렉토리가 다른 디렉토리도 가리킬 수 있게 함으로써 구현된다.

**DIRECTORY ROOT**

|   NAME   | IS DIRECTORY |  CREATED   | LAST MODIFIED | OWNER | READ/WRITE | BLOCKS  |
| :------: | :----------: | :--------: | :-----------: | :---: | :--------: | :-----: |
| todo.txt |      no      | 2023/05/13 |  2023/06/05   | user1 |    r/w     | 1, 6, 7 |
| abc.wav  |      no      | 2023/02/12 |  2023/04/12   | user2 |     r      |    2    |
| test.py  |      no      | 2023/06/05 |  2023/06/14   | user1 |    r/w     |  3, 5   |
|  a.out   |      no      | 2023/06/14 |  2023/06/14   | user2 |    r/w     |    4    |
|   bin    |     yes      | 2023/06/15 |  2023/06/15   | user1 |    r/w     |    8    |

**DIRECTORY bin**

| NAME  | IS DIRECTORY |  CREATED   | LAST MODIFIED | OWNER | READ/WRITE |   BLOCKS   |
| :---: | :----------: | :--------: | :-----------: | :---: | :--------: | :--------: |
|  gcc  |      no      | 2023/03/02 |  2023/03/02   | root  |     x      | 13, 22, 14 |
|  g++  |      no      | 2023/03/03 |  2023/03/03   | root  |     x      |     99     |

이런 방법을 사용하면 파일을 쉽게 옮길 수 있다.

기존의 디렉토리에서 파일의 정보만 제거하고 새로운 디렉토리에 추가함으로써 파일 전체는 기존 블록에 있지만 디렉토리 위치만 쉽게 변경할 수 있다.

